// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package ioc

import (
	"fmt"
	"github.com/crazyfrankie/cloud/internal/auth"
	"github.com/crazyfrankie/cloud/internal/file"
	dao2 "github.com/crazyfrankie/cloud/internal/file/dao"
	"github.com/crazyfrankie/cloud/internal/storage"
	"github.com/crazyfrankie/cloud/internal/user"
	"github.com/crazyfrankie/cloud/internal/user/dao"
	"github.com/crazyfrankie/cloud/pkg/conf"
	"github.com/crazyfrankie/cloud/pkg/middlewares"
	"github.com/crazyfrankie/snow-flake"
	"github.com/gin-gonic/gin"
	"github.com/minio/minio-go/v7"
	"github.com/minio/minio-go/v7/pkg/credentials"
	"github.com/redis/go-redis/v9"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/schema"
	"os"
)

// Injectors from wire.go:

func InitEngine() *gin.Engine {
	db := InitDB()
	client := InitMinIO()
	node := InitSnowflake()
	module := user.InitUserModule(db, client, node)
	cmdable := InitRedis()
	authModule := auth.InitAuthModule(module, cmdable)
	tokenService := authModule.Token
	v := InitMws(tokenService)
	userHandler := module.Handler
	authHandler := authModule.Handler
	storageModule := storage.InitStorageModule(client)
	storageHandler := storageModule.Handler
	fileModule := file.InitFileModule(db, storageModule, cmdable, client)
	fileHandler := fileModule.Handler
	engine := InitWeb(v, userHandler, authHandler, storageHandler, fileHandler)
	return engine
}

// wire.go:

func InitDB() *gorm.DB {
	dsn := fmt.Sprintf(conf.GetConf().MySQL.DSN, os.Getenv("MYSQL_USER"), os.Getenv("MYSQL_PASSWORD"), os.Getenv("MYSQL_HOST"), os.Getenv("MYSQL_PORT"), os.Getenv("MYSQL_DB"))

	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		NamingStrategy: schema.NamingStrategy{SingularTable: true},
	})
	if err != nil {
		panic(err)
	}

	db.AutoMigrate(&dao.User{}, &dao2.File{})

	return db
}

func InitMinIO() *minio.Client {
	client, err := minio.New(conf.GetConf().MinIO.Endpoint, &minio.Options{
		Creds: credentials.NewStaticV4(conf.GetConf().MinIO.AccessKey, conf.GetConf().MinIO.SecretKey, ""),
	})
	if err != nil {
		panic(err)
	}

	return client
}

func InitRedis() redis.Cmdable {
	client := redis.NewClient(&redis.Options{
		Addr: conf.GetConf().Redis.Addr,
	})

	return client
}

func InitSnowflake() *snowflake.Node {
	node, err := snowflake.NewNode(1)
	if err != nil {
		panic(err)
	}

	return node
}

func InitWeb(mws []gin.HandlerFunc, user2 *user.Handler, auth2 *auth.Handler, storage2 *storage.Handler, file2 *file.Handler) *gin.Engine {
	srv := gin.Default()

	srv.Use(mws...)
	user2.
		RegisterRoute(srv)
	auth2.
		RegisterRoute(srv)
	storage2.
		RegisterRoute(srv)
	file2.
		RegisterRoute(srv)

	return srv
}

func InitMws(t *auth.TokenService) []gin.HandlerFunc {
	return []gin.HandlerFunc{
		func(c *gin.Context) {
			c.Header("Access-Control-Allow-Origin", "http://localhost:8080")
			c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS, PATCH")
			c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Accept, Authorization")
			c.Header("Access-Control-Expose-Headers", "x-access-token")
			c.Header("Access-Control-Allow-Credentials", "true")

			if c.Request.Method == "OPTIONS" {
				c.AbortWithStatus(204)
				return
			}

			c.Next()
		}, middlewares.NewAuthnHandler(t).
			IgnorePath("/user/register").
			IgnorePath("/auth/login").
			Auth(),
	}
}
